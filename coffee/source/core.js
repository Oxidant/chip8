// Generated by CoffeeScript 1.6.2
(function() {
  this.Core = (function() {
    function Core() {}

    Core.MEMORY_OFFSET = 0x200;

    Core.CACHE_CODE = {};

    Core.prototype.rom = new ROMParser;

    Core.prototype.display = new Display;

    Core.prototype.sound = new Sound;

    Core.prototype.keyboard = new Keyboard;

    Core.prototype.sprites = [0xF0, 0x90, 0x90, 0x90, 0xF0, 0x20, 0x60, 0x20, 0x20, 0x70, 0xF0, 0x10, 0xF0, 0x80, 0xF0, 0xF0, 0x10, 0xF0, 0x10, 0xF0, 0x90, 0x90, 0xF0, 0x10, 0x10, 0xF0, 0x80, 0xF0, 0x10, 0xF0, 0xF0, 0x80, 0xF0, 0x90, 0xF0, 0xF0, 0x10, 0x20, 0x40, 0x40, 0xF0, 0x90, 0xF0, 0x90, 0xF0, 0xF0, 0x90, 0xF0, 0x10, 0xF0, 0xF0, 0x90, 0xF0, 0x90, 0x90, 0xE0, 0x90, 0xE0, 0x90, 0xE0, 0xF0, 0x80, 0x80, 0x80, 0xF0, 0xE0, 0x90, 0x90, 0x90, 0xE0, 0xF0, 0x80, 0xF0, 0x80, 0xF0, 0xF0, 0x80, 0xF0, 0x80, 0x80];

    Core.prototype.reset = function() {
      this.display.init();
      Core.CACHE_CODE = {};
      this.RAM = new Uint8Array(4096);
      this.Stack = [];
      this.V = new Uint8Array(16);
      this.I = 0;
      this.DT = 0;
      this.ST = 0;
      this.PC = Core.MEMORY_OFFSET;
      this.stop = false;
      this.debug = false;
      this.iteration = 0;
      this.fillSprites();
      return this;
    };

    Core.prototype.fillSprites = function() {
      var i, j, _i, _len, _ref, _results;

      _ref = this.sprites;
      _results = [];
      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
        i = _ref[j];
        _results.push(this.RAM[j] = i);
      }
      return _results;
    };

    Core.prototype.loadROM = function(rom) {
      var _this = this;

      return this.rom.loadFile(rom, function(file) {
        return _this.RAM.set(file.file, Core.MEMORY_OFFSET);
      });
    };

    Core.prototype.decT = function() {
      if (this.DT) {
        this.DT--;
      }
      if (this.ST) {
        this.sound.beep();
        return this.ST--;
      }
    };

    Core.prototype.incPC = function(step) {
      return this.inc('PC', step);
    };

    Core.prototype.inc = function(rg, step) {
      return this[rg] += step != null ? step : 2;
    };

    Core.prototype.step = function() {
      var code, _i;

      for (_i = 0; _i < 10; _i++) {
        if (!this.stop) {
          code = this.getCode(this.PC);
          this.incPC();
          this.decT();
          this.exec(code);
        } else {
          break;
        }
      }
      if (!this.stop) {
        this.timer();
      }
      return code;
    };

    Core.prototype.getCode = function(addr) {
      var addrInc, d0, d1, data, total;

      if (addr == null) {
        addr = Core.MEMORY_OFFSET;
      }
      addrInc = addr;
      if (!Core.CACHE_CODE[addr]) {
        d0 = this.RAM[addrInc++];
        d1 = this.RAM[addrInc];
        data = [];
        total = d0 << 8 | d1;
        data.push(data.code = total);
        data.push(d0 >> 4);
        data.push(d0 & 0xF);
        data.push(d1 >> 4);
        data.push(d1 & 0xF);
        data.push(total & 0xFFF);
        data.push(d0);
        data.push(d1);
        Core.CACHE_CODE[addr] = data;
      }
      return Core.CACHE_CODE[addr];
    };

    Core.prototype.run = function() {
      return this.timer();
    };

    Core.prototype.timer = function(time, timer) {
      var _this = this;

      if (time == null) {
        time = 20;
      }
      if (timer == null) {
        timer = 'DT';
      }
      return requestAnimationFrame(function() {
        return _this.step();
      });
    };

    Core.prototype.start = function() {
      this.reset();
      return this.loadROM('games/BRIX');
    };

    Core.prototype.exec = function(op) {
      var X, Y, carry, coordX, coordY, height, i, sprite, sub, sum, value, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2,
        _this = this;

      if (this.debug) {
        debugger;
      }
      switch (op[1]) {
        case 0x0:
          switch (op[5]) {
            case 0xEE:
              return this.PC = this.Stack.shift();
            case 0xE0:
              return this.display.clear();
            default:
              return this.PC = op[5];
          }
          break;
        case 0x1:
          return this.PC = op[5];
        case 0x2:
          this.Stack.unshift(this.PC);
          return this.PC = op[5];
        case 0x3:
          if (this.V[op[2]] === op[7]) {
            return this.incPC();
          }
          break;
        case 0x4:
          if (this.V[op[2]] !== op[7]) {
            return this.incPC();
          }
          break;
        case 0x5:
          if (this.V[op[2]] === this.V[op[3]]) {
            return this.incPC();
          }
          break;
        case 0x6:
          return this.V[op[2]] = op[7];
        case 0x7:
          return this.V[op[2]] += op[7];
        case 0x8:
          X = op[2];
          Y = op[3];
          switch (op[4]) {
            case 0x0:
              return this.V[X] = this.V[Y];
            case 0x1:
              return this.V[X] |= this.V[Y];
            case 0x2:
              return this.V[X] &= this.V[Y];
            case 0x3:
              return this.V[X] ^= this.V[Y];
            case 0x4:
              sum = this.V[X] + this.V[Y];
              carry = sum > 255 ? 1 : 0;
              this.V[X] = sum;
              return this.V[0xF] = carry;
            case 0x5:
              sub = this.V[X] - this.V[Y];
              carry = this.V[X] > this.V[Y] ? 1 : 0;
              this.V[X] = sub;
              return this.V[0xF] = carry;
            case 0x6:
              /*	
              						8XY6	Shifts VX right by one. VF is set to the value of the least significant bit of VX before the shift.
              								On the original interpreter, the value of VY is shifted, and the result is stored into VX. 
              								On current implementations, Y is ignored.
              */

              carry = this.V[X] & 0x1;
              this.V[X] >>= 1;
              return this.V[0xF] = carry;
            case 0x7:
              sub = this.V[Y] - this.V[X];
              carry = this.V[Y] > this.V[X] ? 1 : 0;
              this.V[X] = sub;
              return this.V[0xF] = carry;
            case 0xE:
              /*
              						8XYE	Shifts VX left by one. VF is set to the value of the most significant bit of VX before the shift.
              								On the original interpreter, the value of VY is shifted, and the result is stored into VX. 
              								On current implementations, Y is ignored.
              */

              carry = this.V[X] & 128 ? 1 : 0;
              this.V[X] <<= 1;
              return this.V[0xF] = carry;
          }
          break;
        case 0x9:
          if (this.V[X] !== this.V[Y]) {
            return this.incPC();
          }
          break;
        case 0xA:
          return this.I = op[5];
        case 0xB:
          return this.PC = op[5] + this.V[0];
        case 0xC:
          return this.V[op[2]] = Math.random() * 0xFF & op[7];
        case 0xD:
          /*
          				DXYN	Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels.
          						Each row of 8 pixels is read as bit-coded (with the most significant bit of each byte displayed 
          						on the left) starting from memory location I; I value doesn't change after the execution of this
          						instruction. As described above, VF is set to 1 if any screen pixels are flipped from set to unset
          						when the sprite is drawn, and to 0 if that doesn't happen.
          */

          this.V[0xF] = 0;
          if (this.iteration === 103) {
            this.debug = true;
          }
          coordX = this.V[op[2]];
          coordY = this.V[op[3]];
          height = op[4];
          for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
            sprite = this.RAM[this.I + y];
            for (x = _j = 0; _j < 8; x = ++_j) {
              if (sprite & 128 ? this.display.setPixel(coordX + x, coordY + y) : void 0) {
                this.V[0xF] = 1;
              }
              sprite <<= 1;
            }
          }
          return true;
        case 0xE:
          switch (op[7]) {
            case 0x9E:
              if (this.V[op[2]] === this.keyboard.key) {
                return this.incPC();
              }
              break;
            case 0xA1:
              if (this.V[op[2]] !== this.keyboard.key) {
                return this.incPC();
              }
          }
          break;
        case 0xF:
          switch (op[7]) {
            case 0x07:
              return this.V[op[2]] = this.DT;
            case 0x0A:
              this.stop = true;
              return this.keyboard.await(function(key) {
                _this.V[op[2]] = _this.keyboard.key;
                _this.stop = false;
                return _this.run();
              });
            case 0x15:
              return this.DT = this.V[op[2]];
            case 0x18:
              return this.ST = this.V[op[2]];
            case 0x1E:
              /*
              						FX1E	Adds VX to I.
              								VF is set to 1 when range overflow (I+VX>0xFFF),
              								and 0 when there isn't. This is undocumented feature of the Chip-8 and used by 
              								Spacefight 2019! game.
              */

              sum = this.I + this.V[op[2]];
              carry = sum > 0xFFF ? 1 : 0;
              this.I = sum;
              return this.V[0xF] = carry;
            case 0x29:
              return this.I = this.V[op[2]] * 5;
            case 0x33:
              /*
              						FX33	Stores the Binary-coded decimal representation of VX, with the most significant of 
              								three digits at the address in I, the middle digit at I plus 1, and the least significant
              								digit at I plus 2. (In other words, take the decimal representation of VX, place the hundreds 
              								digit in memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.)
              */

              value = this.V[op[2]];
              return _ref = [value / 100 % 10, value / 10 % 10, value % 10], this.RAM[this.I] = _ref[0], this.RAM[this.I + 1] = _ref[1], this.RAM[this.I + 2] = _ref[2], _ref;
            case 0x55:
              /*
              						FX55	Stores V0 to VX in memory starting at address I.
              								On the original interpreter, when the operation is done, I=I+X+1.
              */

              for (i = _k = 0, _ref1 = op[2]; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
                this.RAM[this.I + i] = this.V[i];
              }
              return this.inc('I', op[2] + 2);
            case 0x65:
              /*
              						FX65	Fills V0 to VX with values from memory starting at address I.
              								On the original interpreter, when the operation is done, I=I+X+1
              */

              for (i = _l = 0, _ref2 = op[2]; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
                this.V[i] = this.RAM[this.I + i];
              }
              return this.inc('I', op[2] + 2);
          }
          break;
        default:
          return console.log("%s not recognized", op[0].toString(16));
      }
    };

    return Core;

  })();

}).call(this);
